# ==============================================================================
# Ashley AI - Failsafe & Self-Repair System
# Version 30.0 - With Integrated "Guardian" Security Module
# ==============================================================================
import os, sys, json, subprocess, traceback, time
from pathlib import Path

# ==============================================================================
# --- THE MASTER BLUEPRINT: ALL COMPONENTS OF ASHLEY ---
# ==============================================================================

# --- KNOWLEDGE BASE (with new security keywords) ---
KNOWLEDGE_BASE_CONTENT = {
  "keywords": {
    "repair": "action_master_repair", "gui": "action_launch_gui",
    "security status": "action_security_report", "who is here": "action_security_report",
    "add person": "action_add_person", "new user": "action_add_person",
    "lock down": "action_lockdown", "initiate security scan": "action_security_scan"
  }
}
# --- SECURE DATABASE TEMPLATE ---
HOUSEHOLD_DB_TEMPLATE = {"people": []} # A list of person objects

# --- REPAIR WORKER (with new audio analysis dependencies) ---
REPAIR_WORKER_CODE = """
import sys, subprocess, importlib.util
def _s(text): print(text)
# Manifest now includes libraries for voice biometrics
REQUIRED_MODULES = {"psutil":"psutil", "opencv-python":"cv2", "pyttsx3":"pyttsx3", "face_recognition":"face_recognition", "dlib":"dlib", "scipy":"scipy", "librosa":"librosa", "numpy":"numpy"}
_s("Initiating dependency repair for all modules, including the Guardian.")
missing = {pkg: imp for pkg, imp in REQUIRED_MODULES.items() if not importlib.util.find_spec(imp)}
if not missing: _s("All required libraries are installed."); print("REPAIR_SUCCESS"); exit()
_s(f"Found {len(missing)} missing libraries. Beginning installation.")
failed = []
for pkg in missing:
    _s(f"Installing {pkg}...")
    try: subprocess.run([sys.executable, "-m", "pip", "install", pkg], check=True, capture_output=True)
    except: failed.append(pkg)
if not failed: _s("All dependencies installed."); print("REPAIR_SUCCESS")
else: _s(f"Could not install: {', '.join(failed)}."); print("REPAIR_FAIL")
"""

# --- NEW GUARDIAN WORKER (guardian_worker.py) ---
GUARDIAN_WORKER_CODE = """
import sys, os, json, time, numpy as np
from pathlib import Path
# This worker will have its own safe imports
def _s(text): print(text)

BASE_DIR = Path(__file__).resolve().parent
DB_PATH = BASE_DIR / "household_db.json"
FACE_DATA_DIR = BASE_DIR / "face_data"

def load_db():
    try:
        with open(DB_PATH, 'r') as f: return json.load(f)
    except: return {"people": []}

def save_db(data):
    with open(DB_PATH, 'w') as f: json.dump(data, f, indent=2)

def add_person():
    import cv2
    FACE_DATA_DIR.mkdir(exist_ok=True)
    _s("Beginning new person enrollment sequence.")
    name = input("Guardian > Please state the name of the new person: ").strip()
    if not name: _s("Enrollment cancelled. Name cannot be empty."); return
    
    access_level = input(f"Guardian > What access level for {name}? (1:Family, 2:Guest, 3:Restricted): ").strip()
    
    _s(f"Please look directly at the camera to capture a facial image for {name}.")
    cap = cv2.VideoCapture(0, cv2.CAP_DSHOW)
    time.sleep(2) # Allow camera to warm up
    ret, frame = cap.read()
    cap.release(); cv2.destroyAllWindows()
    
    if not ret: _s("[FAIL] Could not capture image from camera."); return
    
    person_img_path = FACE_DATA_DIR / f"{name}.jpg"
    cv2.imwrite(str(person_img_path), frame)
    _s(f"Facial data saved to {person_img_path.name}.")
    
    # In a real system, we'd enroll voiceprints here too.
    
    db = load_db()
    # Remove existing entry if it exists
    db["people"] = [p for p in db["people"] if p["name"].lower() != name.lower()]
    db["people"].append({"name": name, "access_level": access_level, "face_image": str(person_img_path.name)})
    save_db(db)
    _s(f"Enrollment complete. {name} has been added to the household database with access level {access_level}.")
    
def security_scan():
    import cv2, face_recognition
    _s("Initiating real-time security scan. I am watching.")
    FACE_DATA_DIR.mkdir(exist_ok=True)
    db = load_db()
    
    known_face_encodings = []
    known_face_names = []
    
    _s("Loading known identities from database...")
    for person in db.get("people", []):
        try:
            image_path = FACE_DATA_DIR / person["face_image"]
            if image_path.exists():
                person_image = face_recognition.load_image_file(str(image_path))
                person_face_encoding = face_recognition.face_encodings(person_image)[0]
                known_face_encodings.append(person_face_encoding)
                known_face_names.append(f"{person['name']} (L{person['access_level']})")
        except: pass
    _s("Identity data loaded. Activating camera.")

    cap = cv2.VideoCapture(0, cv2.CAP_DSHOW)
    while True:
        ret, frame = cap.read()
        if not ret: break
        rgb_small = cv2.resize(frame, (0,0), fx=0.25, fy=0.25)[:,:,::-1]
        
        face_locations = face_recognition.face_locations(rgb_small)
        face_encodings = face_recognition.face_encodings(rgb_small, face_locations)
        
        for face_encoding in face_encodings:
            matches = face_recognition.compare_faces(known_face_encodings, face_encoding)
            name = "Unknown (Level 0)"
            if True in matches: name = known_face_names[matches.index(True)]
            # In a real system, you would log this detection or trigger an alert.
            print(f"DETECTION: {name}")

        cv2.imshow('Guardian Scan', frame)
        if cv2.waitKey(1) & 0xFF == ord('q'): break
        
    cap.release(); cv2.destroyAllWindows()
    _s("Security scan terminated.")

def security_report():
    db = load_db()
    people = db.get("people", [])
    if not people: _s("The household database is empty. No people are registered."); return
    _s("Generating security report:")
    for person in people:
        _s(f"- Name: {person['name']}, Access Level: {person['access_level']}")
    _s("Report complete.")

if __name__ == "__main__":
    command = sys.argv[1] if len(sys.argv) > 1 else ""
    if command == "add_person": add_person()
    elif command == "scan": security_scan()
    elif command == "report": security_report()
"""

# Other worker blueprints... (Chatbot, GUI, TTS) are unchanged and minified
CHATBOT_WORKER_CODE = "import sys,json,os;i=' '.join(sys.argv[1:]).lower().strip();print(next((a for k,a in json.load(open(os.path.join(os.path.dirname(os.path.abspath(__file__)),'ashley_knowledge.json'))).get('keywords',{}).items() if k in i),\"I don't have a response for that yet.\"))"
GUI_WORKER_CODE = "import tkinter as tk;r=tk.Tk();r.title('Ashley AI');r.mainloop()"
TTS_WORKER_CODE = "import sys,pyttsx3;e=pyttsx3.init();e.say(' '.join(sys.argv[1:]));e.runAndWait()"

# ==============================================================================
# --- THE UNCRASHABLE COCKPIT (FAILSAFE) ---
# ==============================================================================
class Cockpit:
    def __init__(self, base_dir):
        self.base_dir = base_dir; self.python_exe = sys.executable
        self.action_handler = {
            "action_master_repair": self._run_master_repair,
            "action_launch_gui": self._run_gui,
            "action_add_person": lambda: self._run_worker("guardian_worker.py", "add_person"),
            "action_security_scan": lambda: self._run_worker("guardian_worker.py", "scan"),
            "action_security_report": lambda: self._run_worker("guardian_worker.py", "report", stream_output=True),
            "action_lockdown": lambda: self.respond("Lockdown protocol not yet implemented."),
        }

    def _run_worker(self, script_name, *args, **kwargs):
        command = [self.python_exe, str(self.base_dir / script_name)] + list(args)
        stream = kwargs.get('stream_output', False)
        try:
            if stream:
                p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, creationflags=getattr(subprocess,'CREATE_NO_WINDOW',0))
                for line in iter(p.stdout.readline,''):
                    if clean_line := line.strip(): self.respond(clean_line)
                p.wait()
            else: return subprocess.run(command,capture_output=True,text=True,check=False,creationflags=getattr(subprocess,'CREATE_NO_WINDOW',0)).stdout.strip()
        except Exception as e: return f"Worker failed: {e}"

    def respond(self, text):
        print(f"Ashley > {text}")
        self._run_worker("tts_worker.py", text)

    def _run_gui(self): self.respond("Launching GUI."); self._run_worker("main_gui.py")
    
    def _run_master_repair(self):
        self.respond("Acknowledged. Initiating master repair for all systems, including Guardian module.")
        initial_startup_check(self.base_dir, silent=True)
        self.respond("Core files verified. Checking all dependencies.")
        self._run_worker("repair_worker.py", stream_output=True)
        self.respond("Repair sequence complete.")
        
    def process_command(self, command_text):
        response = self._run_worker("chatbot_worker.py", command_text, capture_output=True)
        if response in self.action_handler: self.action_handler[response]()
        else: self.respond(response or "My thought process encountered an error.")

    def run(self):
        print("\n<<< ASHLEY AI - FAILSAFE CLI ACTIVE >>>")
        self.respond("Failsafe systems online. Guardian module is on standby.")
        while True:
            try:
                user_input = input("\nYou (Failsafe)> ").strip()
                if user_input.lower() == 'exit': self.respond("Goodbye."); break
                if user_input: self.process_command(user_input)
            except (KeyboardInterrupt, EOFError): self.respond("Shutdown signal received."); break

# ==============================================================================
# --- INITIAL STARTUP SEQUENCE ---
# ==============================================================================
def initial_startup_check(base_dir, silent=False):
    if not silent: print("--- Ashley Failsafe: Verifying system integrity... ---")
    (base_dir / "face_data").mkdir(exist_ok=True) # Create folder for face images
    
    required_files = {
        "chatbot_worker.py": CHATBOT_WORKER_CODE, "repair_worker.py": REPAIR_WORKER_CODE,
        "guardian_worker.py": GUARDIAN_WORKER_CODE, # Add the new Guardian worker
        "main_gui.py": GUI_WORKER_CODE, "tts_worker.py": TTS_WORKER_CODE,
        "ashley_knowledge.json": json.dumps(KNOWLEDGE_BASE_CONTENT, indent=2),
        "household_db.json": json.dumps(HOUSEHOLD_DB_TEMPLATE, indent=2)
    }
    
    for filename, content in required_files.items():
        filepath = base_dir / filename
        if not filepath.exists() or ".py" in filename: # Always overwrite code for updates
            with open(filepath, "w", encoding="utf-8") as f: f.write(content.strip())
            
    if not silent: print("--- Initial check complete. Launching Failsafe CLI. ---")

if __name__ == "__main__":
    try:
        base_dir = Path(__file__).resolve().parent
        initial_startup_check(base_dir)
        Cockpit(base_dir).run()
    except Exception as e:
        print(f"\nFATAL COCKPIT ERROR: {e}\n{traceback.format_exc()}")
    finally:
        print("\n--- Ashley Failsafe session has concluded. ---"); input("Press Enter to exit...")
