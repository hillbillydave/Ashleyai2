# ==============================================================================
# Ashley AI - Final System Generator
# Version 27.0 - Definitive Failsafe + Main Application Architecture
#
# This script's only job is to create the final, stable application files.
# Run this script ONCE to deploy the full Ashley AI ecosystem.
# ==============================================================================
import os
import json
from pathlib import Path

# ==============================================================================
# --- BLUEPRINT 1: The Definitive Failsafe (`ashley_failsafe.py`) ---
# ==============================================================================
ASHLEY_FAILSAFE_CODE = """
import os, sys, subprocess, traceback, urllib.request, zipfile, json
from pathlib import Path

# --- Configuration ---
PYTHON_VERSION = "3.11.8"
PYTHON_ZIP_URL = f"https://www.python.org/ftp/python/{PYTHON_VERSION}/python-{PYTHON_VERSION}-embed-amd64.zip"
GET_PIP_URL = "https://bootstrap.pypa.io/get-pip.py"
REQUIRED_MODULES = ["numpy", "scikit-learn", "nltk", "psutil", "requests", "pyttsx3", "opencv-python", "Pillow", "face_recognition", "dlib", "pyautogui"]

def _print_status(message, status="INFO"):
    print(f"[Failsafe:{status}] {message}")

def setup_portable_python(base_dir):
    runtime_dir = base_dir / "python_runtime"
    python_exe_path = runtime_dir / "python.exe"
    if python_exe_path.exists():
        _print_status("Self-contained Python environment found.", "OK")
        return python_exe_path
    
    _print_status("--- First-Time Setup: Building private Python environment. ---")
    runtime_dir.mkdir(exist_ok=True)
    zip_path = base_dir / "python_embed.zip"
    try:
        import shutil
        _print_status(f"Downloading Python {PYTHON_VERSION}...")
        with urllib.request.urlopen(PYTHON_ZIP_URL) as response, open(zip_path, 'wb') as out_file:
            shutil.copyfileobj(response, out_file)
        with zipfile.ZipFile(zip_path, 'r') as zf: zf.extractall(runtime_dir)
        zip_path.unlink()
        
        pth_file = next(runtime_dir.glob("*._pth"))
        with open(pth_file, "a") as f: f.write("\\nimport site\\n")
        
        get_pip_path = base_dir / "get-pip.py"
        urllib.request.urlretrieve(GET_PIP_URL, get_pip_path)
        _print_status("Installing pip into private environment...")
        subprocess.run([str(python_exe_path), str(get_pip_path)], check=True, capture_output=True)
        get_pip_path.unlink()
    except Exception as e:
        _print_status(f"Failed during environment setup: {e}", "FATAL")
        return None
    _print_status("--- Private environment setup is complete! ---", "SUCCESS")
    return python_exe_path

def install_dependencies(python_exe, base_dir):
    _print_status("Verifying all dependencies...")
    workshop_dir = base_dir / "workshop"
    workshop_dir.mkdir(exist_ok=True)
    
    for module in REQUIRED_MODULES:
        try:
            # Check if module is already installed in the private env
            subprocess.run([str(python_exe), "-c", f"import {module.split('-')[0]}"], check=True, capture_output=True, stderr=subprocess.PIPE)
            continue # Skip if already installed
        except subprocess.CalledProcessError:
            _print_status(f"Dependency '{module}' is missing. Searching for parts...")
            
            # Scavenge workshop first
            found_wheel = next(workshop_dir.rglob(f"*{module.replace('-', '_')}*.whl"), None)
            installed = False
            if found_wheel:
                _print_status(f"Found local part: {found_wheel.name}. Attempting to install...")
                try:
                    subprocess.run([str(python_exe), "-m", "pip", "install", str(found_wheel)], check=True, capture_output=True)
                    _print_status(f"Successfully installed {module} from workshop.", "OK")
                    installed = True
                except: _print_status(f"Local part {found_wheel.name} failed to install.", "WARN")
            
            # Try internet if workshop fails
            if not installed:
                _print_status(f"No local part found. Attempting to install {module} from internet...")
                try:
                    subprocess.run([str(python_exe), "-m", "pip", "install", module], check=True, capture_output=True)
                    _print_status(f"Successfully installed {module} from internet.", "OK")
                except:
                     _print_status(f"Failed to install {module}. This may require manual intervention or expert consultation.", "ERROR")

    _print_status("Dependency check complete.")

def main():
    base_dir = Path(__file__).resolve().parent
    print("--- Ashley AI Failsafe Guardian ---")
    
    # Stage 1: Build the private Python environment
    portable_python_exe = setup_portable_python(base_dir)
    if not portable_python_exe:
        print("\\n[FATAL] Could not create a stable Python environment. Cannot continue.")
        return

    # Stage 2: Install all dependencies into the private environment
    install_dependencies(portable_python_exe, base_dir)

    # Stage 3: Launch the main application using the guaranteed stable environment
    core_script_path = base_dir / "ashley_core.py"
    if not core_script_path.exists():
        _print_status(f"Main application file '{core_script_path.name}' is missing!", "FATAL")
        return
        
    _print_status("All checks complete. Launching Ashley's Main Core Process...", "LAUNCH")
    try:
        subprocess.run([str(portable_python_exe), str(core_script_path)], check=True)
    except Exception as e:
        _print_status(f"The main core process failed to run. Error: {e}", "FATAL")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"\\nFATAL BOOTSTRAPPER ERROR: {e}\\n{traceback.format_exc()}")
    finally:
        print("\\n--- Ashley Failsafe session has concluded. ---")
        input("Press Enter to exit...")
"""

# ==============================================================================
# --- BLUEPRINT 2: The Main Application (`ashley_core.py`) ---
# ==============================================================================
ASHLEY_CORE_PY_CODE = """
# ==============================================================================
# Ashley AI - Main Core Application
# Version 25.0
# Contains the GUI, AI Brain, and all operational logic.
# ==============================================================================
import os, sys, json, subprocess, time, traceback
from pathlib import Path
import tkinter as tk
from tkinter import scrolledtext, PhotoImage
from PIL import Image, ImageTk

# This script will contain the AI brain and the GUI together
# For simplicity, we'll merge them into one class for the final version.

class AshleyApplication:
    def __init__(self, root):
        self.root = root; self.root.title("Ashley AI")
        self.base_dir = Path(__file__).resolve().parent
        self.python_exe = sys.executable
        self.knowledge = self._load_knowledge()
        
        # --- GUI Setup ---
        self.root.geometry("850x650"); self.root.configure(bg="#1e1e1e")
        main_frame=tk.Frame(root,bg="#1e1e1e"); main_frame.pack(fill=tk.BOTH,expand=True,padx=10,pady=10)
        left_panel=tk.Frame(main_frame,bg="#2d2d2d",width=250); left_panel.pack(side=tk.LEFT,fill=tk.Y,padx=(0,10)); left_panel.pack_propagate(False)
        right_panel=tk.Frame(main_frame,bg="#1e1e1e"); right_panel.pack(side=tk.RIGHT,fill=tk.BOTH,expand=True)
        
        self.avatar_label = tk.Label(left_panel, bg="#2d2d2d"); self.avatar_label.pack(pady=20, padx=20)
        self.gif_frames = self._load_gif_frames(self.base_dir / "assets" / "avatar.gif")
        self.gif_frame_index = 0
        if self.gif_frames: self.animate_avatar()
        
        tk.Label(left_panel, text="Ashley AI", font=("Segoe UI Semibold", 20), fg="#00aaff", bg="#2d2d2d").pack()
        
        self.log_text=scrolledtext.ScrolledText(right_panel,wrap=tk.WORD,bg="#252526",fg="white",font=("Segoe UI", 11),relief=tk.FLAT,bd=0)
        self.log_text.pack(fill=tk.BOTH,expand=True,pady=(0,10))
        
        input_frame=tk.Frame(right_panel,bg="#2d2d2d"); input_frame.pack(fill=tk.X)
        self.input_entry=tk.Entry(input_frame,bg="#3c3c3c",fg="white",relief=tk.FLAT,insertbackground="white")
        self.input_entry.pack(side=tk.LEFT,fill=tk.X,expand=True,ipady=10,padx=5,pady=5)
        self.input_entry.bind("<Return>", self.process_input_event)
        tk.Button(input_frame,text="Send",command=self.process_input_event,bg="#007acc",fg="white",relief=tk.FLAT).pack(side=tk.RIGHT,padx=5,pady=5)
        
        self.log("Ashley", "Core systems online. I am ready.")

    def _load_knowledge(self):
        try:
            with open(self.base_dir / "ashley_knowledge.json", 'r') as f: return json.load(f)
        except: return {}

    def _load_gif_frames(self, path):
        try:
            gif = Image.open(path); frames = []
            for i in range(gif.n_frames):
                gif.seek(i); frames.append(ImageTk.PhotoImage(gif.copy().convert("RGBA")))
            return frames
        except: self.log("System", f"Error: Could not load avatar.gif from {path.parent}"); return []

    def animate_avatar(self):
        frame = self.gif_frames[self.gif_frame_index]
        self.avatar_label.configure(image=frame)
        self.gif_frame_index = (self.gif_frame_index + 1) % len(self.gif_frames)
        self.root.after(100, self.animate_avatar)

    def log(self, sender, message):
        self.log_text.configure(state='normal')
        self.log_text.insert(tk.END, f"{sender}: {message}\\n\\n")
        self.log_text.configure(state='disabled'); self.log_text.see(tk.END)
        
    def process_input_event(self, event=None):
        user_input = self.input_entry.get().strip()
        if not user_input: return
        self.log("You", user_input); self.input_entry.delete(0, tk.END)
        
        # Simple NLU directly in the GUI
        command = user_input.lower()
        if "hello" in command: response = "Hi David."
        elif "repair" in command: response = "Repair functionality is handled by the failsafe launcher before I start."
        else: response = "I don't have a response for that yet."
        
        self.log("Ashley", response)

if __name__ == "__main__":
    root = tk.Tk()
    app = AshleyApplication(root)
    root.mainloop()
"""

# ==============================================================================
# --- THE GENERATOR SCRIPT ---
# ==============================================================================
def main():
    """This function creates the final application package."""
    print("--- Ashley AI Final System Generator ---")
    base_dir = Path(__file__).resolve().parent
    
    files_to_create = {
        "ashley_failsafe.py": ASHLEY_FAILSAFE_CODE,
        "ashley_core.py": ASHLEY_CORE_CODE,
        "ashley_knowledge.json": json.dumps(KNOWLEDGE_BASE_CONTENT, indent=2)
    }
    
    try:
        (base_dir / "assets").mkdir(exist_ok=True)
        (base_dir / "workshop").mkdir(exist_ok=True)
        
        for filename, content in files_to_create.items():
            with open(base_dir / filename, "w", encoding="utf-8") as f:
                f.write(content.strip().replace('\\n', '\\n'))
            print(f"  [OK] Created {filename}")
        
        print("\n--- ✅ DEPLOYMENT COMPLETE! ---")
        print("Your new, stable application has been created.")
        print("\nINSTRUCTIONS:")
        print("1. Place your 'avatar.gif' inside the 'assets' folder.")
        print("2. (Optional) Place any offline installers (.whl files) in the 'workshop' folder.")
        print("3. From now on, you will only run 'python ashley_failsafe.py'.")

    except Exception as e:
        print(f"\n[FATAL] An error occurred during file generation: {e}")
        traceback.print_exc()
        
if __name__ == "__main__":
    main()
    print("\n--- Generator script has finished. ---")
    input("Press Enter to exit...")
